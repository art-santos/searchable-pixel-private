<<<<<<< HEAD
{"version":3,"sources":["../src/middleware.ts","../src/constants.ts","../src/detector.ts","../src/tracker.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server'\nimport { detectAICrawler, extractRequestMetadata, UnknownCrawlerInfo } from './detector'\nimport { CrawlerTracker, TrackerConfig } from './tracker'\nimport { CrawlerInfo } from './constants'\n\n// Global tracker instance\nlet tracker: CrawlerTracker | null = null\n\nexport interface MiddlewareConfig extends TrackerConfig {\n  // Paths to exclude from tracking\n  exclude?: string[]\n  // Paths to include (if specified, only these paths are tracked)\n  include?: string[]\n  // Whether to add custom headers for crawlers\n  addCrawlerHeaders?: boolean\n  // Custom logic to run when crawler is detected\n  onCrawlerDetected?: (request: NextRequest, crawler: CrawlerInfo | UnknownCrawlerInfo) => void | Promise<void>\n}\n\n/**\n * Create Next.js middleware for AI crawler tracking\n */\nexport function createCrawlerMiddleware(config: MiddlewareConfig) {\n  // Initialize tracker if not already done\n  if (!tracker) {\n    tracker = new CrawlerTracker(config)\n  }\n\n  return async function middleware(request: NextRequest) {\n    const startTime = Date.now()\n    \n    try {\n      // Check if path should be tracked\n      const pathname = request.nextUrl.pathname\n      \n      if (config.exclude) {\n        const shouldExclude = config.exclude.some(pattern => {\n          if (pattern.includes('*')) {\n            const regex = new RegExp(pattern.replace(/\\*/g, '.*'))\n            return regex.test(pathname)\n          }\n          return pathname.startsWith(pattern)\n        })\n        \n        if (shouldExclude) {\n          return NextResponse.next()\n        }\n      }\n      \n      if (config.include) {\n        const shouldInclude = config.include.some(pattern => {\n          if (pattern.includes('*')) {\n            const regex = new RegExp(pattern.replace(/\\*/g, '.*'))\n            return regex.test(pathname)\n          }\n          return pathname.startsWith(pattern)\n        })\n        \n        if (!shouldInclude) {\n          return NextResponse.next()\n        }\n      }\n\n      // Detect AI crawler\n      const userAgent = request.headers.get('user-agent')\n      const detection = detectAICrawler(userAgent)\n\n      if (!detection.isAICrawler || !detection.crawler) {\n        return NextResponse.next()\n      }\n\n      // Call custom handler if provided\n      if (config.onCrawlerDetected) {\n        await config.onCrawlerDetected(request, detection.crawler)\n      }\n\n      // Create response (could be modified if needed)\n      const response = NextResponse.next()\n\n      // Add custom headers if requested\n      if (config.addCrawlerHeaders) {\n        response.headers.set('X-AI-Crawler-Detected', 'true')\n        response.headers.set('X-AI-Crawler-Name', detection.crawler.bot)\n        response.headers.set('X-AI-Crawler-Company', detection.crawler.company)\n      }\n\n      // Extract metadata\n      const metadata = extractRequestMetadata({\n        headers: Object.fromEntries(request.headers.entries()),\n        url: request.url,\n        method: request.method\n      })\n\n      // Calculate response time\n      const responseTimeMs = Date.now() - startTime\n\n      // Ensure tracker is initialized (TypeScript safety)\n      if (!tracker) {\n        tracker = new CrawlerTracker(config)\n      }\n\n      // Track the event\n      const event = tracker.createEvent(\n        detection.crawler,\n        {\n          url: request.url,\n          headers: Object.fromEntries(request.headers.entries()),\n          statusCode: response.status,\n          responseTimeMs\n        },\n        metadata\n      )\n\n      // Track asynchronously to not block the response\n      tracker.track(event).catch(error => {\n        if (config.debug) {\n          console.error('[Split Analytics] Failed to track event:', error)\n        }\n      })\n\n      return response\n\n    } catch (error) {\n      // Don't let tracking errors break the application\n      if (config.debug) {\n        console.error('[Split Analytics] Middleware error:', error)\n      }\n      return NextResponse.next()\n    }\n  }\n}\n\n/**\n * Cleanup function to call when shutting down\n */\nexport function destroyTracker() {\n  if (tracker) {\n    tracker.destroy()\n    tracker = null\n  }\n} ","// Known AI crawler user agents\nexport const AI_CRAWLERS = {\n  // OpenAI (3 main crawlers)\n  'GPTBot': { company: 'OpenAI', bot: 'GPTBot', category: 'ai-training' },\n  'ChatGPT-User': { company: 'OpenAI', bot: 'ChatGPT-User', category: 'ai-assistant' },\n  'OAI-SearchBot': { company: 'OpenAI', bot: 'OAI-SearchBot', category: 'ai-search' },\n  \n  // Anthropic\n  'Claude-Web': { company: 'Anthropic', bot: 'Claude-Web', category: 'ai-assistant' },\n  'ClaudeBot': { company: 'Anthropic', bot: 'ClaudeBot', category: 'ai-training' },\n  'anthropic-ai': { company: 'Anthropic', bot: 'anthropic-ai', category: 'ai-training' },\n  \n  // Google/Alphabet\n  'Google-Extended': { company: 'Google', bot: 'Google-Extended', category: 'ai-training' },\n  'Googlebot': { company: 'Google', bot: 'Googlebot', category: 'search-ai' },\n  'Googlebot-Image': { company: 'Google', bot: 'Googlebot-Image', category: 'search-ai' },\n  'Googlebot-News': { company: 'Google', bot: 'Googlebot-News', category: 'search-ai' },\n  'Google-InspectionTool': { company: 'Google', bot: 'Google-InspectionTool', category: 'search-ai' },\n  \n  // Microsoft\n  'Bingbot': { company: 'Microsoft', bot: 'Bingbot', category: 'search-ai' },\n  'msnbot': { company: 'Microsoft', bot: 'msnbot', category: 'search-ai' },\n  'BingPreview': { company: 'Microsoft', bot: 'BingPreview', category: 'search-ai' },\n  \n  // Perplexity\n  'PerplexityBot': { company: 'Perplexity', bot: 'PerplexityBot', category: 'ai-search' },\n  \n  // Meta/Facebook\n  'FacebookBot': { company: 'Meta', bot: 'FacebookBot', category: 'social-ai' },\n  'facebookexternalhit': { company: 'Meta', bot: 'facebookexternalhit', category: 'social-ai' },\n  'Meta-ExternalAgent': { company: 'Meta', bot: 'Meta-ExternalAgent', category: 'ai-training' },\n  \n  // Other AI Search Engines\n  'YouBot': { company: 'You.com', bot: 'YouBot', category: 'ai-search' },\n  'Neeva': { company: 'Neeva', bot: 'Neeva', category: 'ai-search' },\n  'Phind': { company: 'Phind', bot: 'Phind', category: 'ai-search' },\n  \n  // Chinese AI Companies\n  'Bytespider': { company: 'ByteDance', bot: 'Bytespider', category: 'ai-training' },\n  'Baiduspider': { company: 'Baidu', bot: 'Baiduspider', category: 'search-ai' },\n  'Sogou': { company: 'Sogou', bot: 'Sogou', category: 'search-ai' },\n  \n  // E-commerce & Enterprise\n  'Amazonbot': { company: 'Amazon', bot: 'Amazonbot', category: 'ai-assistant' },\n  'LinkedInBot': { company: 'LinkedIn', bot: 'LinkedInBot', category: 'social-ai' },\n  'Twitterbot': { company: 'Twitter', bot: 'Twitterbot', category: 'social-ai' },\n  \n  // Apple\n  'Applebot': { company: 'Apple', bot: 'Applebot', category: 'search-ai' },\n  'Applebot-Extended': { company: 'Apple', bot: 'Applebot-Extended', category: 'ai-training' },\n  \n  // Data Extraction & Analysis\n  'Diffbot': { company: 'Diffbot', bot: 'Diffbot', category: 'ai-extraction' },\n  'DataForSeoBot': { company: 'DataForSEO', bot: 'DataForSeoBot', category: 'ai-extraction' },\n  'SemrushBot': { company: 'Semrush', bot: 'SemrushBot', category: 'ai-extraction' },\n  'AhrefsBot': { company: 'Ahrefs', bot: 'AhrefsBot', category: 'ai-extraction' },\n  \n  // Common Crawl & Research\n  'CCBot': { company: 'Common Crawl', bot: 'CCBot', category: 'ai-training' },\n  'ia_archiver': { company: 'Internet Archive', bot: 'ia_archiver', category: 'archival' },\n  \n  // Other Notable AI Crawlers\n  'PetalBot': { company: 'Petal Search', bot: 'PetalBot', category: 'search-ai' },\n  'SeznamBot': { company: 'Seznam', bot: 'SeznamBot', category: 'search-ai' },\n  'Yandex': { company: 'Yandex', bot: 'YandexBot', category: 'search-ai' },\n  'DuckDuckBot': { company: 'DuckDuckGo', bot: 'DuckDuckBot', category: 'search-ai' },\n  'Qwantify': { company: 'Qwant', bot: 'Qwantify', category: 'search-ai' },\n} as const\n\nexport type CrawlerInfo = typeof AI_CRAWLERS[keyof typeof AI_CRAWLERS]\n\n// Default API endpoint\nexport const DEFAULT_API_ENDPOINT = 'https://split.dev/api/crawler-events'\n\n// Batch settings\nexport const BATCH_SIZE = 10\nexport const BATCH_INTERVAL_MS = 5000 // 5 seconds\nexport const MAX_RETRY_ATTEMPTS = 3\nexport const RETRY_DELAY_MS = 1000 ","import { AI_CRAWLERS, CrawlerInfo } from './constants'\n\n// Type for unknown crawlers\nexport interface UnknownCrawlerInfo {\n  company: string\n  bot: string\n  category: string\n}\n\nexport interface CrawlerDetectionResult {\n  isAICrawler: boolean\n  crawler?: CrawlerInfo | UnknownCrawlerInfo\n  userAgent: string\n}\n\n/**\n * Detects if a user agent string belongs to an AI crawler\n */\nexport function detectAICrawler(userAgent: string | null): CrawlerDetectionResult {\n  if (!userAgent) {\n    return {\n      isAICrawler: false,\n      userAgent: ''\n    }\n  }\n\n  // Check each known crawler pattern\n  for (const [pattern, info] of Object.entries(AI_CRAWLERS)) {\n    if (userAgent.includes(pattern)) {\n      return {\n        isAICrawler: true,\n        crawler: info,\n        userAgent\n      }\n    }\n  }\n\n  // Additional checks for less specific patterns\n  const lowerUA = userAgent.toLowerCase()\n  \n  // Check for bot patterns that might indicate AI crawlers\n  const aiPatterns = [\n    'ai-crawler',\n    'ai-bot',\n    'llm-crawler',\n    'training-bot',\n    'ml-bot'\n  ]\n  \n  for (const pattern of aiPatterns) {\n    if (lowerUA.includes(pattern)) {\n      return {\n        isAICrawler: true,\n        crawler: {\n          company: 'Unknown',\n          bot: pattern,\n          category: 'unknown'\n        } as UnknownCrawlerInfo,\n        userAgent\n      }\n    }\n  }\n\n  return {\n    isAICrawler: false,\n    userAgent\n  }\n}\n\n/**\n * Extract additional metadata from the request\n */\nexport function extractRequestMetadata(request: {\n  headers: Record<string, string | string[] | undefined>\n  url?: string\n  method?: string\n}) {\n  const metadata: Record<string, any> = {}\n\n  // Extract referer\n  const referer = request.headers['referer'] || request.headers['referrer']\n  if (referer) {\n    metadata.referer = Array.isArray(referer) ? referer[0] : referer\n  }\n\n  // Extract accept headers to understand what the crawler wants\n  const accept = request.headers['accept']\n  if (accept) {\n    metadata.accept = Array.isArray(accept) ? accept.join(', ') : accept\n  }\n\n  // Extract encoding\n  const encoding = request.headers['accept-encoding']\n  if (encoding) {\n    metadata.acceptEncoding = Array.isArray(encoding) ? encoding.join(', ') : encoding\n  }\n\n  // Extract language preferences\n  const language = request.headers['accept-language']\n  if (language) {\n    metadata.acceptLanguage = Array.isArray(language) ? language[0] : language\n  }\n\n  return metadata\n} ","import { CrawlerInfo } from './constants'\nimport { UnknownCrawlerInfo } from './detector'\nimport { \n  DEFAULT_API_ENDPOINT, \n  BATCH_SIZE, \n  BATCH_INTERVAL_MS,\n  MAX_RETRY_ATTEMPTS,\n  RETRY_DELAY_MS \n} from './constants'\n\nexport interface CrawlerEvent {\n  timestamp: string\n  domain: string\n  path: string\n  crawlerName: string\n  crawlerCompany: string\n  crawlerCategory: string\n  userAgent: string\n  statusCode?: number\n  responseTimeMs?: number\n  country?: string\n  metadata?: Record<string, any>\n}\n\nexport interface TrackerConfig {\n  apiKey: string\n  apiEndpoint?: string\n  batchSize?: number\n  batchIntervalMs?: number\n  debug?: boolean\n  onError?: (error: Error) => void\n}\n\nexport interface PingResponse {\n  status: 'ok' | 'error'\n  connection?: {\n    authenticated: boolean\n    keyName: string\n    workspace: string\n    domain: string | null\n  }\n  message?: string\n  timestamp?: string\n}\n\nexport class CrawlerTracker {\n  private config: Required<TrackerConfig>\n  private eventQueue: CrawlerEvent[] = []\n  private batchTimer: NodeJS.Timeout | null = null\n  private isSending = false\n\n  constructor(config: TrackerConfig) {\n    this.config = {\n      apiKey: config.apiKey,\n      apiEndpoint: config.apiEndpoint || DEFAULT_API_ENDPOINT,\n      batchSize: config.batchSize || BATCH_SIZE,\n      batchIntervalMs: config.batchIntervalMs || BATCH_INTERVAL_MS,\n      debug: config.debug || false,\n      onError: config.onError || ((error) => console.error('[Split Analytics]', error))\n    }\n  }\n\n  /**\n   * Track a crawler visit\n   */\n  async track(event: Omit<CrawlerEvent, 'timestamp'>) {\n    const fullEvent: CrawlerEvent = {\n      ...event,\n      timestamp: new Date().toISOString()\n    }\n\n    this.eventQueue.push(fullEvent)\n\n    if (this.config.debug) {\n      console.log('[Split Analytics] Event queued:', fullEvent)\n    }\n\n    // Check if we should send immediately\n    if (this.eventQueue.length >= this.config.batchSize) {\n      await this.flush()\n    } else {\n      // Schedule batch send\n      this.scheduleBatch()\n    }\n  }\n\n  /**\n   * Create a tracking event from request data\n   */\n  createEvent(\n    crawler: CrawlerInfo | UnknownCrawlerInfo,\n    request: {\n      url: string\n      headers: Record<string, string | string[] | undefined>\n      statusCode?: number\n      responseTimeMs?: number\n    },\n    metadata?: Record<string, any>\n  ): Omit<CrawlerEvent, 'timestamp'> {\n    const url = new URL(request.url)\n    \n    return {\n      domain: url.hostname,\n      path: url.pathname,\n      crawlerName: crawler.bot,\n      crawlerCompany: crawler.company,\n      crawlerCategory: crawler.category,\n      userAgent: this.getHeaderValue(request.headers['user-agent']) || '',\n      statusCode: request.statusCode,\n      responseTimeMs: request.responseTimeMs,\n      metadata\n    }\n  }\n\n  /**\n   * Schedule a batch send\n   */\n  private scheduleBatch() {\n    if (this.batchTimer) return\n\n    this.batchTimer = setTimeout(async () => {\n      this.batchTimer = null\n      if (this.eventQueue.length > 0) {\n        await this.flush()\n      }\n    }, this.config.batchIntervalMs)\n  }\n\n  /**\n   * Send all queued events\n   */\n  async flush() {\n    if (this.isSending || this.eventQueue.length === 0) return\n\n    this.isSending = true\n    const events = [...this.eventQueue]\n    this.eventQueue = []\n\n    try {\n      await this.sendBatch(events)\n    } catch (error) {\n      // Put events back in queue for retry\n      this.eventQueue.unshift(...events)\n      this.config.onError(error as Error)\n    } finally {\n      this.isSending = false\n    }\n  }\n\n  /**\n   * Send a batch of events with retry logic\n   */\n  private async sendBatch(events: CrawlerEvent[], attempt = 1): Promise<void> {\n    try {\n      const response = await fetch(this.config.apiEndpoint, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${this.config.apiKey}`,\n          'X-Split-Version': '0.1.0'\n        },\n        body: JSON.stringify({ events })\n      })\n\n      if (!response.ok) {\n        throw new Error(`API error: ${response.status} ${response.statusText}`)\n      }\n\n      if (this.config.debug) {\n        console.log(`[Split Analytics] Sent ${events.length} events`)\n      }\n    } catch (error) {\n      if (attempt < MAX_RETRY_ATTEMPTS) {\n        // Exponential backoff\n        const delay = RETRY_DELAY_MS * Math.pow(2, attempt - 1)\n        if (this.config.debug) {\n          console.log(`[Split Analytics] Retry attempt ${attempt} after ${delay}ms`)\n        }\n        await new Promise(resolve => setTimeout(resolve, delay))\n        return this.sendBatch(events, attempt + 1)\n      }\n      throw error\n    }\n  }\n\n  /**\n   * Helper to get header value\n   */\n  private getHeaderValue(header: string | string[] | undefined): string | undefined {\n    if (!header) return undefined\n    return Array.isArray(header) ? header[0] : header\n  }\n\n  /**\n   * Cleanup resources\n   */\n  destroy() {\n    if (this.batchTimer) {\n      clearTimeout(this.batchTimer)\n      this.batchTimer = null\n    }\n    // Try to send remaining events\n    this.flush().catch(() => {})\n  }\n\n  /**\n   * Ping the API to verify connection and API key validity\n   */\n  async ping(): Promise<PingResponse> {\n    try {\n      const pingEndpoint = this.config.apiEndpoint.replace(/\\/events$/, '/ping')\n      \n      const response = await fetch(pingEndpoint, {\n        method: 'GET',\n        headers: {\n          'Authorization': `Bearer ${this.config.apiKey}`,\n          'X-Split-Version': '0.1.0'\n        }\n      })\n\n      const data = await response.json() as PingResponse\n\n      if (!response.ok) {\n        return {\n          status: 'error',\n          message: data.message || `API error: ${response.status}`\n        }\n      }\n\n      if (this.config.debug) {\n        console.log('[Split Analytics] Ping successful:', data)\n      }\n\n      return data\n    } catch (error) {\n      if (this.config.debug) {\n        console.error('[Split Analytics] Ping failed:', error)\n      }\n      \n      return {\n        status: 'error',\n        message: error instanceof Error ? error.message : 'Connection failed'\n      }\n    }\n  }\n} "],"mappings":"AAAA,OAAsB,gBAAAA,MAAoB,cCCnC,IAAMC,EAAc,CAEzB,OAAU,CAAE,QAAS,SAAU,IAAK,SAAU,SAAU,aAAc,EACtE,eAAgB,CAAE,QAAS,SAAU,IAAK,eAAgB,SAAU,cAAe,EACnF,gBAAiB,CAAE,QAAS,SAAU,IAAK,gBAAiB,SAAU,WAAY,EAGlF,aAAc,CAAE,QAAS,YAAa,IAAK,aAAc,SAAU,cAAe,EAClF,UAAa,CAAE,QAAS,YAAa,IAAK,YAAa,SAAU,aAAc,EAC/E,eAAgB,CAAE,QAAS,YAAa,IAAK,eAAgB,SAAU,aAAc,EAGrF,kBAAmB,CAAE,QAAS,SAAU,IAAK,kBAAmB,SAAU,aAAc,EACxF,UAAa,CAAE,QAAS,SAAU,IAAK,YAAa,SAAU,WAAY,EAC1E,kBAAmB,CAAE,QAAS,SAAU,IAAK,kBAAmB,SAAU,WAAY,EACtF,iBAAkB,CAAE,QAAS,SAAU,IAAK,iBAAkB,SAAU,WAAY,EACpF,wBAAyB,CAAE,QAAS,SAAU,IAAK,wBAAyB,SAAU,WAAY,EAGlG,QAAW,CAAE,QAAS,YAAa,IAAK,UAAW,SAAU,WAAY,EACzE,OAAU,CAAE,QAAS,YAAa,IAAK,SAAU,SAAU,WAAY,EACvE,YAAe,CAAE,QAAS,YAAa,IAAK,cAAe,SAAU,WAAY,EAGjF,cAAiB,CAAE,QAAS,aAAc,IAAK,gBAAiB,SAAU,WAAY,EAGtF,YAAe,CAAE,QAAS,OAAQ,IAAK,cAAe,SAAU,WAAY,EAC5E,oBAAuB,CAAE,QAAS,OAAQ,IAAK,sBAAuB,SAAU,WAAY,EAC5F,qBAAsB,CAAE,QAAS,OAAQ,IAAK,qBAAsB,SAAU,aAAc,EAG5F,OAAU,CAAE,QAAS,UAAW,IAAK,SAAU,SAAU,WAAY,EACrE,MAAS,CAAE,QAAS,QAAS,IAAK,QAAS,SAAU,WAAY,EACjE,MAAS,CAAE,QAAS,QAAS,IAAK,QAAS,SAAU,WAAY,EAGjE,WAAc,CAAE,QAAS,YAAa,IAAK,aAAc,SAAU,aAAc,EACjF,YAAe,CAAE,QAAS,QAAS,IAAK,cAAe,SAAU,WAAY,EAC7E,MAAS,CAAE,QAAS,QAAS,IAAK,QAAS,SAAU,WAAY,EAGjE,UAAa,CAAE,QAAS,SAAU,IAAK,YAAa,SAAU,cAAe,EAC7E,YAAe,CAAE,QAAS,WAAY,IAAK,cAAe,SAAU,WAAY,EAChF,WAAc,CAAE,QAAS,UAAW,IAAK,aAAc,SAAU,WAAY,EAG7E,SAAY,CAAE,QAAS,QAAS,IAAK,WAAY,SAAU,WAAY,EACvE,oBAAqB,CAAE,QAAS,QAAS,IAAK,oBAAqB,SAAU,aAAc,EAG3F,QAAW,CAAE,QAAS,UAAW,IAAK,UAAW,SAAU,eAAgB,EAC3E,cAAiB,CAAE,QAAS,aAAc,IAAK,gBAAiB,SAAU,eAAgB,EAC1F,WAAc,CAAE,QAAS,UAAW,IAAK,aAAc,SAAU,eAAgB,EACjF,UAAa,CAAE,QAAS,SAAU,IAAK,YAAa,SAAU,eAAgB,EAG9E,MAAS,CAAE,QAAS,eAAgB,IAAK,QAAS,SAAU,aAAc,EAC1E,YAAe,CAAE,QAAS,mBAAoB,IAAK,cAAe,SAAU,UAAW,EAGvF,SAAY,CAAE,QAAS,eAAgB,IAAK,WAAY,SAAU,WAAY,EAC9E,UAAa,CAAE,QAAS,SAAU,IAAK,YAAa,SAAU,WAAY,EAC1E,OAAU,CAAE,QAAS,SAAU,IAAK,YAAa,SAAU,WAAY,EACvE,YAAe,CAAE,QAAS,aAAc,IAAK,cAAe,SAAU,WAAY,EAClF,SAAY,CAAE,QAAS,QAAS,IAAK,WAAY,SAAU,WAAY,CACzE,EAKaC,EAAuB,uCAGvBC,EAAa,GACbC,EAAoB,IACpBC,EAAqB,EACrBC,EAAiB,IC5DvB,SAASC,EAAgBC,EAAkD,CAChF,GAAI,CAACA,EACH,MAAO,CACL,YAAa,GACb,UAAW,EACb,EAIF,OAAW,CAACC,EAASC,CAAI,IAAK,OAAO,QAAQC,CAAW,EACtD,GAAIH,EAAU,SAASC,CAAO,EAC5B,MAAO,CACL,YAAa,GACb,QAASC,EACT,UAAAF,CACF,EAKJ,IAAMI,EAAUJ,EAAU,YAAY,EAGhCK,EAAa,CACjB,aACA,SACA,cACA,eACA,QACF,EAEA,QAAWJ,KAAWI,EACpB,GAAID,EAAQ,SAASH,CAAO,EAC1B,MAAO,CACL,YAAa,GACb,QAAS,CACP,QAAS,UACT,IAAKA,EACL,SAAU,SACZ,EACA,UAAAD,CACF,EAIJ,MAAO,CACL,YAAa,GACb,UAAAA,CACF,CACF,CAKO,SAASM,EAAuBC,EAIpC,CACD,IAAMC,EAAgC,CAAC,EAGjCC,EAAUF,EAAQ,QAAQ,SAAcA,EAAQ,QAAQ,SAC1DE,IACFD,EAAS,QAAU,MAAM,QAAQC,CAAO,EAAIA,EAAQ,CAAC,EAAIA,GAI3D,IAAMC,EAASH,EAAQ,QAAQ,OAC3BG,IACFF,EAAS,OAAS,MAAM,QAAQE,CAAM,EAAIA,EAAO,KAAK,IAAI,EAAIA,GAIhE,IAAMC,EAAWJ,EAAQ,QAAQ,iBAAiB,EAC9CI,IACFH,EAAS,eAAiB,MAAM,QAAQG,CAAQ,EAAIA,EAAS,KAAK,IAAI,EAAIA,GAI5E,IAAMC,EAAWL,EAAQ,QAAQ,iBAAiB,EAClD,OAAIK,IACFJ,EAAS,eAAiB,MAAM,QAAQI,CAAQ,EAAIA,EAAS,CAAC,EAAIA,GAG7DJ,CACT,CC3DO,IAAMK,EAAN,KAAqB,CAM1B,YAAYC,EAAuB,CAJnC,KAAQ,WAA6B,CAAC,EACtC,KAAQ,WAAoC,KAC5C,KAAQ,UAAY,GAGlB,KAAK,OAAS,CACZ,OAAQA,EAAO,OACf,YAAaA,EAAO,aAAeC,EACnC,UAAWD,EAAO,WAAaE,EAC/B,gBAAiBF,EAAO,iBAAmBG,EAC3C,MAAOH,EAAO,OAAS,GACvB,QAASA,EAAO,UAAaI,GAAU,QAAQ,MAAM,oBAAqBA,CAAK,EACjF,CACF,CAKA,MAAM,MAAMC,EAAwC,CAClD,IAAMC,EAA0B,CAC9B,GAAGD,EACH,UAAW,IAAI,KAAK,EAAE,YAAY,CACpC,EAEA,KAAK,WAAW,KAAKC,CAAS,EAE1B,KAAK,OAAO,OACd,QAAQ,IAAI,kCAAmCA,CAAS,EAItD,KAAK,WAAW,QAAU,KAAK,OAAO,UACxC,MAAM,KAAK,MAAM,EAGjB,KAAK,cAAc,CAEvB,CAKA,YACEC,EACAC,EAMAC,EACiC,CACjC,IAAMC,EAAM,IAAI,IAAIF,EAAQ,GAAG,EAE/B,MAAO,CACL,OAAQE,EAAI,SACZ,KAAMA,EAAI,SACV,YAAaH,EAAQ,IACrB,eAAgBA,EAAQ,QACxB,gBAAiBA,EAAQ,SACzB,UAAW,KAAK,eAAeC,EAAQ,QAAQ,YAAY,CAAC,GAAK,GACjE,WAAYA,EAAQ,WACpB,eAAgBA,EAAQ,eACxB,SAAAC,CACF,CACF,CAKQ,eAAgB,CAClB,KAAK,aAET,KAAK,WAAa,WAAW,SAAY,CACvC,KAAK,WAAa,KACd,KAAK,WAAW,OAAS,GAC3B,MAAM,KAAK,MAAM,CAErB,EAAG,KAAK,OAAO,eAAe,EAChC,CAKA,MAAM,OAAQ,CACZ,GAAI,KAAK,WAAa,KAAK,WAAW,SAAW,EAAG,OAEpD,KAAK,UAAY,GACjB,IAAME,EAAS,CAAC,GAAG,KAAK,UAAU,EAClC,KAAK,WAAa,CAAC,EAEnB,GAAI,CACF,MAAM,KAAK,UAAUA,CAAM,CAC7B,OAASP,EAAO,CAEd,KAAK,WAAW,QAAQ,GAAGO,CAAM,EACjC,KAAK,OAAO,QAAQP,CAAc,CACpC,QAAE,CACA,KAAK,UAAY,EACnB,CACF,CAKA,MAAc,UAAUO,EAAwBC,EAAU,EAAkB,CAC1E,GAAI,CACF,IAAMC,EAAW,MAAM,MAAM,KAAK,OAAO,YAAa,CACpD,OAAQ,OACR,QAAS,CACP,eAAgB,mBAChB,cAAiB,UAAU,KAAK,OAAO,MAAM,GAC7C,kBAAmB,OACrB,EACA,KAAM,KAAK,UAAU,CAAE,OAAAF,CAAO,CAAC,CACjC,CAAC,EAED,GAAI,CAACE,EAAS,GACZ,MAAM,IAAI,MAAM,cAAcA,EAAS,MAAM,IAAIA,EAAS,UAAU,EAAE,EAGpE,KAAK,OAAO,OACd,QAAQ,IAAI,0BAA0BF,EAAO,MAAM,SAAS,CAEhE,OAASP,EAAO,CACd,GAAIQ,EAAUE,EAAoB,CAEhC,IAAMC,EAAQC,EAAiB,KAAK,IAAI,EAAGJ,EAAU,CAAC,EACtD,OAAI,KAAK,OAAO,OACd,QAAQ,IAAI,mCAAmCA,CAAO,UAAUG,CAAK,IAAI,EAE3E,MAAM,IAAI,QAAQE,GAAW,WAAWA,EAASF,CAAK,CAAC,EAChD,KAAK,UAAUJ,EAAQC,EAAU,CAAC,CAC3C,CACA,MAAMR,CACR,CACF,CAKQ,eAAec,EAA2D,CAChF,GAAKA,EACL,OAAO,MAAM,QAAQA,CAAM,EAAIA,EAAO,CAAC,EAAIA,CAC7C,CAKA,SAAU,CACJ,KAAK,aACP,aAAa,KAAK,UAAU,EAC5B,KAAK,WAAa,MAGpB,KAAK,MAAM,EAAE,MAAM,IAAM,CAAC,CAAC,CAC7B,CAKA,MAAM,MAA8B,CAClC,GAAI,CACF,IAAMC,EAAe,KAAK,OAAO,YAAY,QAAQ,YAAa,OAAO,EAEnEN,EAAW,MAAM,MAAMM,EAAc,CACzC,OAAQ,MACR,QAAS,CACP,cAAiB,UAAU,KAAK,OAAO,MAAM,GAC7C,kBAAmB,OACrB,CACF,CAAC,EAEKC,EAAO,MAAMP,EAAS,KAAK,EAEjC,OAAKA,EAAS,IAOV,KAAK,OAAO,OACd,QAAQ,IAAI,qCAAsCO,CAAI,EAGjDA,GAVE,CACL,OAAQ,QACR,QAASA,EAAK,SAAW,cAAcP,EAAS,MAAM,EACxD,CAQJ,OAAST,EAAO,CACd,OAAI,KAAK,OAAO,OACd,QAAQ,MAAM,iCAAkCA,CAAK,EAGhD,CACL,OAAQ,QACR,QAASA,aAAiB,MAAQA,EAAM,QAAU,mBACpD,CACF,CACF,CACF,EH/OA,IAAIiB,EAAiC,KAgB9B,SAASC,EAAwBC,EAA0B,CAEhE,OAAKF,IACHA,EAAU,IAAIG,EAAeD,CAAM,GAG9B,eAA0BE,EAAsB,CACrD,IAAMC,EAAY,KAAK,IAAI,EAE3B,GAAI,CAEF,IAAMC,EAAWF,EAAQ,QAAQ,SAEjC,GAAIF,EAAO,SACaA,EAAO,QAAQ,KAAKK,GACpCA,EAAQ,SAAS,GAAG,EACR,IAAI,OAAOA,EAAQ,QAAQ,MAAO,IAAI,CAAC,EACxC,KAAKD,CAAQ,EAErBA,EAAS,WAAWC,CAAO,CACnC,EAGC,OAAOC,EAAa,KAAK,EAI7B,GAAIN,EAAO,SASL,CARkBA,EAAO,QAAQ,KAAKK,GACpCA,EAAQ,SAAS,GAAG,EACR,IAAI,OAAOA,EAAQ,QAAQ,MAAO,IAAI,CAAC,EACxC,KAAKD,CAAQ,EAErBA,EAAS,WAAWC,CAAO,CACnC,EAGC,OAAOC,EAAa,KAAK,EAK7B,IAAMC,EAAYL,EAAQ,QAAQ,IAAI,YAAY,EAC5CM,EAAYC,EAAgBF,CAAS,EAE3C,GAAI,CAACC,EAAU,aAAe,CAACA,EAAU,QACvC,OAAOF,EAAa,KAAK,EAIvBN,EAAO,mBACT,MAAMA,EAAO,kBAAkBE,EAASM,EAAU,OAAO,EAI3D,IAAME,EAAWJ,EAAa,KAAK,EAG/BN,EAAO,oBACTU,EAAS,QAAQ,IAAI,wBAAyB,MAAM,EACpDA,EAAS,QAAQ,IAAI,oBAAqBF,EAAU,QAAQ,GAAG,EAC/DE,EAAS,QAAQ,IAAI,uBAAwBF,EAAU,QAAQ,OAAO,GAIxE,IAAMG,EAAWC,EAAuB,CACtC,QAAS,OAAO,YAAYV,EAAQ,QAAQ,QAAQ,CAAC,EACrD,IAAKA,EAAQ,IACb,OAAQA,EAAQ,MAClB,CAAC,EAGKW,EAAiB,KAAK,IAAI,EAAIV,EAG/BL,IACHA,EAAU,IAAIG,EAAeD,CAAM,GAIrC,IAAMc,EAAQhB,EAAQ,YACpBU,EAAU,QACV,CACE,IAAKN,EAAQ,IACb,QAAS,OAAO,YAAYA,EAAQ,QAAQ,QAAQ,CAAC,EACrD,WAAYQ,EAAS,OACrB,eAAAG,CACF,EACAF,CACF,EAGA,OAAAb,EAAQ,MAAMgB,CAAK,EAAE,MAAMC,GAAS,CAC9Bf,EAAO,OACT,QAAQ,MAAM,2CAA4Ce,CAAK,CAEnE,CAAC,EAEML,CAET,OAASK,EAAO,CAEd,OAAIf,EAAO,OACT,QAAQ,MAAM,sCAAuCe,CAAK,EAErDT,EAAa,KAAK,CAC3B,CACF,CACF,CAKO,SAASU,GAAiB,CAC3BlB,IACFA,EAAQ,QAAQ,EAChBA,EAAU,KAEd","names":["NextResponse","AI_CRAWLERS","DEFAULT_API_ENDPOINT","BATCH_SIZE","BATCH_INTERVAL_MS","MAX_RETRY_ATTEMPTS","RETRY_DELAY_MS","detectAICrawler","userAgent","pattern","info","AI_CRAWLERS","lowerUA","aiPatterns","extractRequestMetadata","request","metadata","referer","accept","encoding","language","CrawlerTracker","config","DEFAULT_API_ENDPOINT","BATCH_SIZE","BATCH_INTERVAL_MS","error","event","fullEvent","crawler","request","metadata","url","events","attempt","response","MAX_RETRY_ATTEMPTS","delay","RETRY_DELAY_MS","resolve","header","pingEndpoint","data","tracker","createCrawlerMiddleware","config","CrawlerTracker","request","startTime","pathname","pattern","NextResponse","userAgent","detection","detectAICrawler","response","metadata","extractRequestMetadata","responseTimeMs","event","error","destroyTracker"]}
=======
{"version":3,"sources":["../src/middleware.ts","../src/index.ts"],"sourcesContent":["/**\n * @split.dev/analytics - Next.js Middleware\n * Simple middleware helper for Next.js applications\n */\n\nimport { NextRequest, NextResponse } from 'next/server'\nimport { SplitAnalytics, SplitConfig, isAICrawler, getCrawlerInfo } from './index'\n\nexport interface MiddlewareConfig extends SplitConfig {\n  /** Paths to exclude from tracking (regex patterns) */\n  exclude?: string[]\n  /** Paths to include for tracking (regex patterns) - if specified, only these paths are tracked */\n  include?: string[]\n}\n\n/**\n * Create Split Analytics middleware for Next.js\n * \n * @example\n * // Simple usage in middleware.ts\n * import { createSplitMiddleware } from '@split.dev/analytics/middleware'\n * \n * export const middleware = createSplitMiddleware({\n *   apiKey: process.env.SPLIT_API_KEY!,\n *   debug: process.env.NODE_ENV === 'development'\n * })\n * \n * export const config = {\n *   matcher: ['/((?!api|_next/static|_next/image|favicon.ico).*)']\n * }\n */\nexport function createSplitMiddleware(config: MiddlewareConfig) {\n  const analytics = new SplitAnalytics(config)\n  \n  return async function splitMiddleware(request: NextRequest) {\n    const { pathname } = request.nextUrl\n    const userAgent = request.headers.get('user-agent')\n    \n    // Check if path should be excluded\n    if (config.exclude) {\n      for (const pattern of config.exclude) {\n        if (pathname.match(pattern)) {\n          return NextResponse.next()\n        }\n      }\n    }\n    \n    // Check if path should be included (if include patterns are specified)\n    if (config.include && config.include.length > 0) {\n      let shouldInclude = false\n      for (const pattern of config.include) {\n        if (pathname.match(pattern)) {\n          shouldInclude = true\n          break\n        }\n      }\n      if (!shouldInclude) {\n        return NextResponse.next()\n      }\n    }\n    \n    // Only track if it's an AI crawler\n    if (isAICrawler(userAgent)) {\n      const startTime = Date.now()\n      \n      // Continue with the request\n      const response = NextResponse.next()\n      \n      // Track the crawler visit asynchronously (don't block the response)\n      const crawler = getCrawlerInfo(userAgent)\n      if (crawler) {\n        analytics.track({\n          url: request.url,\n          userAgent: userAgent || '',\n          crawler,\n          metadata: {\n            method: request.method,\n            pathname,\n            responseTime: Date.now() - startTime\n          }\n        }).catch(error => {\n          if (config.debug) {\n            console.error('[Split Analytics] Tracking failed:', error)\n          }\n        })\n      }\n      \n      return response\n    }\n    \n    return NextResponse.next()\n  }\n}\n\n/**\n * Helper for users who already have middleware\n * Call this function in your existing middleware to add Split Analytics tracking\n * \n * @example\n * // In your existing middleware.ts\n * import { trackCrawlerVisit } from '@split.dev/analytics/middleware'\n * \n * export async function middleware(request: NextRequest) {\n *   // Your existing middleware logic here\n *   const response = NextResponse.next()\n *   \n *   // Add Split Analytics tracking\n *   await trackCrawlerVisit(request, {\n *     apiKey: process.env.SPLIT_API_KEY!,\n *     debug: process.env.NODE_ENV === 'development'\n *   })\n *   \n *   return response\n * }\n */\nexport async function trackCrawlerVisit(request: NextRequest, config: SplitConfig): Promise<boolean> {\n  const userAgent = request.headers.get('user-agent')\n  \n  if (!isAICrawler(userAgent)) {\n    return false\n  }\n  \n  const analytics = new SplitAnalytics(config)\n  const crawler = getCrawlerInfo(userAgent)\n  \n  if (!crawler) {\n    return false\n  }\n  \n  return analytics.track({\n    url: request.url,\n    userAgent: userAgent || '',\n    crawler,\n    metadata: {\n      method: request.method,\n      pathname: request.nextUrl.pathname\n    }\n  })\n} ","/**\n * @split.dev/analytics\n * Simple AI crawler tracking for any website\n * Zero external dependencies, lightweight, reliable\n */\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport interface SplitConfig {\n  /** Your Split Analytics API key */\n  apiKey: string\n  /** Custom API endpoint (optional) */\n  apiEndpoint?: string\n  /** Enable debug logging */\n  debug?: boolean\n}\n\nexport interface PingResponse {\n  status: 'ok' | 'error'\n  message?: string\n  connection?: {\n    authenticated: boolean\n    keyName: string\n    workspace: string\n    domain: string | null\n  }\n  timestamp?: string\n}\n\nexport interface CrawlerVisit {\n  url: string\n  userAgent: string\n  timestamp: string\n  crawler?: {\n    name: string\n    company: string\n    category: string\n  }\n  metadata?: {\n    method?: string\n    statusCode?: number\n    responseTime?: number\n    [key: string]: any\n  }\n}\n\n// ============================================================================\n// CRAWLER DETECTION - 20+ AI CRAWLERS\n// ============================================================================\n\nconst AI_CRAWLERS = {\n  // OpenAI (3 main crawlers)\n  'GPTBot': { name: 'GPTBot', company: 'OpenAI', category: 'ai-training' },\n  'ChatGPT-User': { name: 'ChatGPT-User', company: 'OpenAI', category: 'ai-assistant' },\n  'OAI-SearchBot': { name: 'OAI-SearchBot', company: 'OpenAI', category: 'ai-search' },\n  \n  // Anthropic\n  'Claude-Web': { name: 'Claude-Web', company: 'Anthropic', category: 'ai-assistant' },\n  'ClaudeBot': { name: 'ClaudeBot', company: 'Anthropic', category: 'ai-training' },\n  'anthropic-ai': { name: 'anthropic-ai', company: 'Anthropic', category: 'ai-training' },\n  \n  // Google/Alphabet\n  'Google-Extended': { name: 'Google-Extended', company: 'Google', category: 'ai-training' },\n  'Googlebot': { name: 'Googlebot', company: 'Google', category: 'search-ai' },\n  'Googlebot-Image': { name: 'Googlebot-Image', company: 'Google', category: 'search-ai' },\n  'Googlebot-News': { name: 'Googlebot-News', company: 'Google', category: 'search-ai' },\n  \n  // Microsoft\n  'Bingbot': { name: 'Bingbot', company: 'Microsoft', category: 'search-ai' },\n  'msnbot': { name: 'msnbot', company: 'Microsoft', category: 'search-ai' },\n  'BingPreview': { name: 'BingPreview', company: 'Microsoft', category: 'search-ai' },\n  \n  // Perplexity\n  'PerplexityBot': { name: 'PerplexityBot', company: 'Perplexity', category: 'ai-search' },\n  \n  // Meta/Facebook\n  'FacebookBot': { name: 'FacebookBot', company: 'Meta', category: 'social-ai' },\n  'facebookexternalhit': { name: 'facebookexternalhit', company: 'Meta', category: 'social-ai' },\n  'Meta-ExternalAgent': { name: 'Meta-ExternalAgent', company: 'Meta', category: 'ai-training' },\n  \n  // Other AI Search Engines\n  'YouBot': { name: 'YouBot', company: 'You.com', category: 'ai-search' },\n  'Neeva': { name: 'Neeva', company: 'Neeva', category: 'ai-search' },\n  'Phind': { name: 'Phind', company: 'Phind', category: 'ai-search' },\n  \n  // Chinese AI Companies\n  'Bytespider': { name: 'Bytespider', company: 'ByteDance', category: 'ai-training' },\n  'Baiduspider': { name: 'Baiduspider', company: 'Baidu', category: 'search-ai' },\n  'Sogou': { name: 'Sogou', company: 'Sogou', category: 'search-ai' },\n  \n  // E-commerce & Enterprise\n  'Amazonbot': { name: 'Amazonbot', company: 'Amazon', category: 'ai-assistant' },\n  'LinkedInBot': { name: 'LinkedInBot', company: 'LinkedIn', category: 'social-ai' },\n  'Twitterbot': { name: 'Twitterbot', company: 'Twitter', category: 'social-ai' },\n  \n  // Apple\n  'Applebot': { name: 'Applebot', company: 'Apple', category: 'search-ai' },\n  'Applebot-Extended': { name: 'Applebot-Extended', company: 'Apple', category: 'ai-training' },\n  \n  // Data Extraction & Analysis\n  'Diffbot': { name: 'Diffbot', company: 'Diffbot', category: 'ai-extraction' },\n  'DataForSeoBot': { name: 'DataForSeoBot', company: 'DataForSEO', category: 'ai-extraction' },\n  'SemrushBot': { name: 'SemrushBot', company: 'Semrush', category: 'ai-extraction' },\n  'AhrefsBot': { name: 'AhrefsBot', company: 'Ahrefs', category: 'ai-extraction' },\n  \n  // Common Crawl & Research\n  'CCBot': { name: 'CCBot', company: 'Common Crawl', category: 'ai-training' },\n  'ia_archiver': { name: 'ia_archiver', company: 'Internet Archive', category: 'archival' },\n  \n  // Other Notable AI Crawlers\n  'PetalBot': { name: 'PetalBot', company: 'Petal Search', category: 'search-ai' },\n  'SeznamBot': { name: 'SeznamBot', company: 'Seznam', category: 'search-ai' },\n  'Yandex': { name: 'YandexBot', company: 'Yandex', category: 'search-ai' },\n  'DuckDuckBot': { name: 'DuckDuckBot', company: 'DuckDuckGo', category: 'search-ai' },\n  'Qwantify': { name: 'Qwantify', company: 'Qwant', category: 'search-ai' },\n} as const\n\nfunction detectCrawler(userAgent: string | null) {\n  if (!userAgent) return null\n  \n  for (const [key, info] of Object.entries(AI_CRAWLERS)) {\n    if (userAgent.includes(key)) {\n      return info\n    }\n  }\n  \n  return null\n}\n\n// ============================================================================\n// CORE SPLIT ANALYTICS CLASS\n// ============================================================================\n\nexport class SplitAnalytics {\n  private config: Required<SplitConfig>\n  \n  constructor(config: SplitConfig) {\n    if (!config.apiKey) {\n      throw new Error('[Split Analytics] API key is required')\n    }\n    \n    this.config = {\n      apiKey: config.apiKey,\n      apiEndpoint: config.apiEndpoint || 'https://split.dev/api',\n      debug: config.debug || false\n    }\n    \n    if (this.config.debug) {\n      console.log('[Split Analytics] Initialized')\n    }\n  }\n  \n  /**\n   * Test connection to Split Analytics API\n   */\n  async ping(): Promise<PingResponse> {\n    try {\n      const response = await fetch(`${this.config.apiEndpoint}/ping`, {\n        method: 'GET',\n        headers: {\n          'Authorization': `Bearer ${this.config.apiKey}`,\n          'Content-Type': 'application/json'\n        }\n      })\n      \n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({ message: 'Unknown error' })) as { message?: string }\n        return {\n          status: 'error',\n          message: errorData.message || `HTTP ${response.status}`\n        }\n      }\n      \n      const data = await response.json() as PingResponse\n      \n      if (this.config.debug) {\n        console.log('[Split Analytics] Ping successful:', data)\n      }\n      \n      return data\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Connection failed'\n      \n      if (this.config.debug) {\n        console.error('[Split Analytics] Ping failed:', error)\n      }\n      \n      return { status: 'error', message }\n    }\n  }\n  \n  /**\n   * Track a crawler visit\n   */\n  async track(visit: Omit<CrawlerVisit, 'timestamp'>): Promise<boolean> {\n    try {\n      const fullVisit: CrawlerVisit = {\n        ...visit,\n        timestamp: new Date().toISOString()\n      }\n      \n      const response = await fetch(`${this.config.apiEndpoint}/crawler-events`, {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${this.config.apiKey}`,\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({ events: [fullVisit] })\n      })\n      \n      if (!response.ok) {\n        if (this.config.debug) {\n          console.error('[Split Analytics] Track failed:', response.status)\n        }\n        return false\n      }\n      \n      if (this.config.debug) {\n        console.log('[Split Analytics] Tracked:', fullVisit.crawler?.name || 'unknown crawler')\n      }\n      \n      return true\n    } catch (error) {\n      if (this.config.debug) {\n        console.error('[Split Analytics] Track error:', error)\n      }\n      return false\n    }\n  }\n  \n  /**\n   * Automatically detect and track crawler from request\n   */\n  async autoTrack(request: {\n    url: string\n    userAgent: string | null\n    method?: string\n    statusCode?: number\n    responseTime?: number\n  }): Promise<boolean> {\n    const crawler = detectCrawler(request.userAgent)\n    \n    if (!crawler) {\n      return false // Not a crawler, nothing to track\n    }\n    \n    return this.track({\n      url: request.url,\n      userAgent: request.userAgent || '',\n      crawler,\n      metadata: {\n        method: request.method,\n        statusCode: request.statusCode,\n        responseTime: request.responseTime\n      }\n    })\n  }\n}\n\n// ============================================================================\n// CONVENIENCE FUNCTIONS\n// ============================================================================\n\n/**\n * Create a new Split Analytics instance\n */\nexport function createSplit(config: SplitConfig): SplitAnalytics {\n  return new SplitAnalytics(config)\n}\n\n/**\n * Quick ping function without creating an instance\n */\nexport async function ping(config: SplitConfig): Promise<PingResponse> {\n  const split = new SplitAnalytics(config)\n  return split.ping()\n}\n\n/**\n * Quick track function without creating an instance\n */\nexport async function track(config: SplitConfig, visit: Omit<CrawlerVisit, 'timestamp'>): Promise<boolean> {\n  const split = new SplitAnalytics(config)\n  return split.track(visit)\n}\n\n/**\n * Detect if a user agent is an AI crawler\n */\nexport function isAICrawler(userAgent: string | null): boolean {\n  return detectCrawler(userAgent) !== null\n}\n\n/**\n * Get crawler information from user agent\n */\nexport function getCrawlerInfo(userAgent: string | null) {\n  return detectCrawler(userAgent)\n} "],"mappings":"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","names":["NextResponse","AI_CRAWLERS","detectCrawler","userAgent","key","info","SplitAnalytics","config","response","data","error","message","visit","fullVisit","request","crawler","isAICrawler","userAgent","detectCrawler","getCrawlerInfo","createSplitMiddleware","config","analytics","SplitAnalytics","request","pathname","userAgent","pattern","NextResponse","shouldInclude","isAICrawler","startTime","response","crawler","getCrawlerInfo","error","trackCrawlerVisit"]}
>>>>>>> 8236b93 (fixed package)
